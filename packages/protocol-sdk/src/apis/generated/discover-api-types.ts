/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/": {
    /** Root */
    get: operations["root__get"];
  };
  "/feed": {
    /** Get Feed */
    get: operations["get_feed_feed_get"];
  };
  "/relevant_mintables/{chain_name}/{collection_address}/{token_id}": {
    /** Gen Relevant Mintables */
    get: operations["gen_relevant_mintables_relevant_mintables__chain_name___collection_address___token_id__get"];
  };
  "/relevant_mintables/{chain_name}/{collection_address}": {
    /** Gen Relevant Mintables */
    get: operations["gen_relevant_mintables_relevant_mintables__chain_name___collection_address__get"];
  };
  "/feed_item_check/{chain_name}/{collection_address}/{token_id}": {
    /** Gen Feed Item Check */
    get: operations["gen_feed_item_check_feed_item_check__chain_name___collection_address___token_id__get"];
  };
  "/feed_item_check/{chain_name}/{collection_address}": {
    /** Gen Feed Item Check */
    get: operations["gen_feed_item_check_feed_item_check__chain_name___collection_address__get"];
  };
  "/mintables/{chain_name}/{collection_address}/{token_id}": {
    /** Gen Mintable */
    get: operations["gen_mintable_mintables__chain_name___collection_address___token_id__get"];
  };
  "/mintables/{chain_name}/{collection_address}": {
    /** Gen Mintable */
    get: operations["gen_mintable_mintables__chain_name___collection_address__get"];
  };
  "/premints/{chain_name}": {
    /** Gen All Mintables */
    get: operations["gen_all_mintables_premints__chain_name__get"];
  };
  "/mintables_v2/{chain_name}/{collection_address}": {
    /** Gen Mintable V2 */
    get: operations["gen_mintable_v2_mintables_v2__chain_name___collection_address__get"];
  };
  "/contract/backfill": {
    /** Gen Backfill Contract */
    post: operations["gen_backfill_contract_contract_backfill_post"];
  };
  "/contract/{chain_name}/{collection_address}": {
    /** Get Contract */
    get: operations["get_contract_contract__chain_name___collection_address__get"];
  };
  "/contract_summaries": {
    /** Gen Contract Summaries */
    post: operations["gen_contract_summaries_contract_summaries_post"];
  };
  "/mint_counts": {
    /**
     * Gen Mint Counts
     * @deprecated
     * @description Use /contract_summaries instead
     */
    post: operations["gen_mint_counts_mint_counts_post"];
  };
  "/contracts": {
    /** Gen Contracts */
    post: operations["gen_contracts_contracts_post"];
  };
  "/tokens/{chain_name}/{collection_address}": {
    /** Gen Contract Tokens */
    get: operations["gen_contract_tokens_tokens__chain_name___collection_address__get"];
  };
  "/user/{wallet}": {
    /** Get User */
    get: operations["get_user_user__wallet__get"];
  };
  "/user/{wallet_address}/tokens": {
    /** Gen User Tokens */
    get: operations["gen_user_tokens_user__wallet_address__tokens_get"];
  };
  "/user/{wallet_address}/contracts": {
    /** Gen User Contracts */
    get: operations["gen_user_contracts_user__wallet_address__contracts_get"];
  };
  "/trending": {
    /** Gen Trending */
    get: operations["gen_trending_trending_get"];
  };
  "/trending_feed": {
    /** Gen Trending Feed */
    get: operations["gen_trending_feed_trending_feed_get"];
  };
  "/search": {
    /** Gen Search */
    get: operations["gen_search_search_get"];
  };
  "/stream/token_mint/{chain_name}/{collection_address}": {
    /** Stream Token Mint */
    get: operations["stream_token_mint_stream_token_mint__chain_name___collection_address__get"];
  };
  "/token_mints/{chain_name}/{collection_address}": {
    /** Gen Token Mints */
    get: operations["gen_token_mints_token_mints__chain_name___collection_address__get"];
  };
  "/stream/mint_comment/{chain_name}/{collection_address}": {
    /** Stream Mint Comment */
    get: operations["stream_mint_comment_stream_mint_comment__chain_name___collection_address__get"];
  };
  "/mint_comments/{chain_name}/{collection_address}": {
    /** Gen Mint Comments */
    get: operations["gen_mint_comments_mint_comments__chain_name___collection_address__get"];
  };
  "/notifications": {
    /** Gen Notifications */
    get: operations["gen_notifications_notifications_get"];
  };
  "/stream/notifications": {
    /** Stream Notification */
    get: operations["stream_notification_stream_notifications_get"];
  };
  "/refresh-blocklist": {
    /** Refresh Blocklist */
    get: operations["refresh_blocklist_refresh_blocklist_get"];
  };
  "/schema": {
    /** Schema */
    get: operations["schema_schema_get"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** BaseModel */
    BaseModel: Record<string, never>;
    /**
     * Chain
     * @description An enumeration.
     * @enum {string}
     */
    Chain: "ETHEREUM" | "ZORA";
    /**
     * ChainName
     * @description An enumeration.
     * @enum {string}
     */
    ChainName:
      | "ETHEREUM-MAINNET"
      | "ETHEREUM-ROPSTEN"
      | "ETHEREUM-RINKEBY"
      | "ETHEREUM-GOERLI"
      | "ETHEREUM-SEPOLIA"
      | "OPTIMISM-MAINNET"
      | "OPTIMISM-GOERLI"
      | "ZORA-GOERLI"
      | "ZORA-MAINNET"
      | "BASE-MAINNET"
      | "BASE-GOERLI"
      | "PGN-MAINNET";
    /** Collection */
    Collection: {
      /** Address */
      address: string;
      /** Name */
      name?: string;
      /** Symbol */
      symbol?: string;
      token_standard?: components["schemas"]["TokenStandard"];
      /** Description */
      description?: string;
      /** Image */
      image?: string;
    };
    /**
     * CollectionCreationConfig
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    CollectionCreationConfig: {
      /** Contractadmin */
      contractAdmin: string;
      /** Contracturi */
      contractURI: string;
      /** Contractname */
      contractName: string;
    };
    /** CollectionTokenId */
    CollectionTokenId: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: number | string;
    };
    /** Collector */
    Collector: {
      /** Address */
      address: string;
      /** Ens Name */
      ens_name?: string;
    };
    /** CollectorSummary */
    CollectorSummary: {
      /** Num Unique Collectors */
      num_unique_collectors: number;
      /** Collector Previews */
      collector_previews: components["schemas"]["Collector"][];
    };
    /** ContractBackfillResponse */
    ContractBackfillResponse: {
      /** Success */
      success: boolean;
      /** Message */
      message: string;
    };
    /** ContractQueryPayload */
    ContractQueryPayload: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
    };
    /** ContractQueryResponse */
    ContractQueryResponse: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      contract_result?: components["schemas"]["ContractResult"];
      /**
       * Err Code
       * @default 0
       */
      err_code?: number;
      /**
       * Err Msg
       * @default
       */
      err_msg?: string;
    };
    /** ContractResult */
    ContractResult: {
      /** Chain Name */
      chain_name: string;
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      collection: components["schemas"]["Collection"];
      contract_type: components["schemas"]["MintableType"];
      /** Creator Address */
      creator_address?: string;
      mintable?: components["schemas"]["Mintable"];
      media?: components["schemas"]["Media"];
      metadata?: components["schemas"]["zora__collect__contract__models__metadata__Metadata"];
      /** Owner */
      owner?: string;
      /** Total Minted */
      total_minted?: number;
    };
    /** ContractSummary */
    ContractSummary: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      /** Mint Count */
      mint_count: number;
      /** Comment Count */
      comment_count: number;
      /** Unique Collector Count */
      unique_collector_count: number;
    };
    /** ContractSummaryResponse */
    ContractSummaryResponse: {
      /** Contract Summary List */
      contract_summary_list: components["schemas"]["ContractSummary"][];
    };
    /** ContractsQueryOutput */
    ContractsQueryOutput: {
      /** Contract Results */
      contract_results: components["schemas"]["ContractQueryResponse"][];
    };
    /** ContractsResponse */
    ContractsResponse: {
      /** Results */
      results: components["schemas"]["ContractResult"][];
      /** Limit */
      limit: number;
      /** Offset */
      offset: number;
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Api Version
       * @default 1
       */
      api_version?: number;
    };
    /**
     * Cursor
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    Cursor: {
      /** First */
      first?: string;
      /** Last */
      last?: string;
    };
    /** ENSRecord */
    ENSRecord: {
      /** Address */
      address: string;
      /** Ens Name */
      ens_name: string;
      text_records: components["schemas"]["ENSTextRecords"];
    };
    /** ENSTextRecords */
    ENSTextRecords: {
      /** Avatar */
      avatar?: string;
      /** Url */
      url?: string;
      /** Description */
      description?: string;
      /** Github */
      github?: string;
      /** Twitter */
      twitter?: string;
      /** Instagram */
      instagram?: string;
      /** Discord */
      discord?: string;
      /** Tiktok */
      tiktok?: string;
    };
    /**
     * EntityType
     * @description An enumeration.
     * @enum {string}
     */
    EntityType: "Collection" | "Token";
    /** FeedItemCheck */
    FeedItemCheck: {
      feed_item?: components["schemas"]["FeedResult"];
      /**
       * Err Msgs
       * @default []
       */
      err_msgs?: string[];
    };
    /**
     * FeedItemType
     * @description An enumeration.
     * @enum {string}
     */
    FeedItemType: "MINTABLE";
    /** FeedResponse */
    FeedResponse: {
      /** Results */
      results: components["schemas"]["FeedResult"][];
      /** Limit */
      limit: number;
      /** Offset */
      offset: number;
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Api Version
       * @default 1
       */
      api_version?: number;
      feed_type?: components["schemas"]["FeedType"];
    };
    /** FeedResult */
    FeedResult: {
      feed_item_type: components["schemas"]["FeedItemType"];
      /** Uuid */
      uuid?: string;
      feed_item: components["schemas"]["Mintable"];
      media?: components["schemas"]["Media"];
    };
    /**
     * FeedType
     * @description An enumeration.
     * @enum {string}
     */
    FeedType:
      | "curated"
      | "most_recent"
      | "heuristic"
      | "trending"
      | "recommendations";
    /**
     * FixedPrice
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    FixedPrice: {
      /** Token Id */
      token_id?: number;
      /** Sale Start */
      sale_start?: string;
      /** Sale End */
      sale_end?: string;
      /** Max Tokens Per Address */
      max_tokens_per_address?: string;
      /** Price Per Token */
      price_per_token?: string;
      /** Funds Recipient */
      funds_recipient?: string;
    };
    /** FoundationMintContext */
    FoundationMintContext: {
      /**
       * Mint Context Type
       * @default foundation
       * @enum {string}
       */
      mint_context_type?: "foundation";
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * InferredMintContext
     * @description Mint context passed to feed via mintables
     *
     * Corresponds to the following TypeScript type:
     * interface InferredMintContext {
     *   price_per_token: string
     *   function_abi: any
     *   function_name: string
     *   contract_address: string
     *   default_eth_value: string
     *   default_args: (string | number)[]
     *   quantity_arg_index: number | null
     *   use_proxy_contract: boolean
     * }
     */
    InferredMintContext: {
      /** Reference Tx */
      reference_tx?: string;
      /** Price Per Token */
      price_per_token: string;
      /** Function Abi */
      function_abi: Record<string, never>;
      /** Function Name */
      function_name: string;
      /** Contract Address */
      contract_address: string;
      /** Default Eth Value */
      default_eth_value: string;
      /** Default Args */
      default_args: (string | number)[];
      /** Expected Tokens Returned */
      expected_tokens_returned: number;
      /** User Address Arg Index */
      user_address_arg_index?: number;
      /** Quantity Arg Index */
      quantity_arg_index?: number;
      /**
       * Use Proxy Contract
       * @default false
       */
      use_proxy_contract?: boolean;
      /**
       * Mint Context Type
       * @default inferred
       * @enum {string}
       */
      mint_context_type?: "inferred";
    };
    /**
     * InfinitePageWithTotal[MintComment]
     * @description This is a generic model for pagination in an infitite scrolling context.
     */
    InfinitePageWithTotal_MintComment_: {
      /** Data */
      data: components["schemas"]["MintComment"][];
      /** Limit */
      limit: number;
      /** Has More */
      has_more: boolean;
      cursor: components["schemas"]["Cursor"];
      /** Total */
      total: number;
    };
    /**
     * InfinitePageWithTotal[TokenMint]
     * @description This is a generic model for pagination in an infitite scrolling context.
     */
    InfinitePageWithTotal_TokenMint_: {
      /** Data */
      data: components["schemas"]["TokenMint"][];
      /** Limit */
      limit: number;
      /** Has More */
      has_more: boolean;
      cursor: components["schemas"]["Cursor"];
      /** Total */
      total: number;
    };
    /**
     * InfinitePage[Mintable]
     * @description This is a generic model for pagination in an infitite scrolling context.
     */
    InfinitePage_Mintable_: {
      /** Data */
      data: components["schemas"]["Mintable"][];
      /** Limit */
      limit: number;
      /** Has More */
      has_more: boolean;
      cursor: components["schemas"]["Cursor"];
    };
    /** ManifoldMintContext */
    ManifoldMintContext: {
      /**
       * Mint Context Type
       * @default manifold
       * @enum {string}
       */
      mint_context_type?: "manifold";
      /** Creator Contract Address */
      creator_contract_address: string;
      /** Claim Index */
      claim_index: number;
      /** Mint Index */
      mint_index: number;
      /**
       * Merkle Proof
       * Format: binary
       */
      merkle_proof: string;
    };
    /** Media */
    Media: {
      image_preview?: components["schemas"]["zora__media_encoding__media__MediaURI"];
      /** Image Carousel */
      image_carousel?: components["schemas"]["zora__media_encoding__media__MediaURI"][];
      content_preview?: components["schemas"]["zora__media_encoding__media__MediaURI"];
      /** Content Carousel */
      content_carousel?: components["schemas"]["zora__media_encoding__media__MediaURI"][];
      /** Mime Type */
      mime_type?: string;
    };
    /** MediaAttribute */
    MediaAttribute: {
      /** Trait Type */
      trait_type?: string;
      /** Value */
      value?: string;
      /** Display Type */
      display_type?: string;
    };
    /** Mint */
    Mint: {
      image_preview: components["schemas"]["zora__collect__trending__models__models__MediaURI"];
      content_preview?: components["schemas"]["zora__collect__trending__models__models__MediaURI"];
      /** Collection Name */
      collection_name: string;
      /** Token Name */
      token_name?: string;
      /** Token Id */
      token_id: string;
      minter: components["schemas"]["Wallet"];
      /**
       * Mint Time
       * Format: date-time
       */
      mint_time: string;
      /** Chain Name */
      chain_name: string;
    };
    /** MintComment */
    MintComment: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      token_standard?: components["schemas"]["TokenStandard"];
      /** From Address */
      from_address: string;
      /** Comment */
      comment: string;
      /** Quantity */
      quantity: number;
      transaction_info: components["schemas"]["TransactionInfo"];
    };
    /** MintCommentNotification */
    MintCommentNotification: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      token_standard?: components["schemas"]["TokenStandard"];
      /**
       * Notification Type
       * @default MINT_COMMENT
       * @enum {string}
       */
      notification_type?: "MINT_COMMENT";
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: string;
      /** Read */
      read: boolean;
      /** Minter Address */
      minter_address: string;
      /** Comment */
      comment: string;
      metadata?: components["schemas"]["zora__ethereum__models__metadata__Metadata"];
      media?: components["schemas"]["zora__media_encoding__media__MediaURI"];
    };
    /** MintCountResponse */
    MintCountResponse: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      /** Mint Count */
      mint_count: number;
    };
    /** MintCountsOutput */
    MintCountsOutput: {
      /** Mint Count Results */
      mint_count_results: components["schemas"]["MintCountResponse"][];
    };
    /** MintNotification */
    MintNotification: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      token_standard?: components["schemas"]["TokenStandard"];
      /**
       * Notification Type
       * @default MINT
       * @enum {string}
       */
      notification_type?: "MINT";
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: string;
      /** Read */
      read: boolean;
      /** Minter Address */
      minter_address: string;
      /** Value */
      value: number;
      metadata?: components["schemas"]["zora__ethereum__models__metadata__Metadata"];
      media?: components["schemas"]["zora__media_encoding__media__MediaURI"];
    };
    /** Mintable */
    Mintable: {
      chain_name: components["schemas"]["ChainName"];
      mintable_type: components["schemas"]["MintableType"];
      token_standard: components["schemas"]["TokenStandard"];
      /** Contract Address */
      contract_address: string;
      /** Creator Address */
      creator_address?: string;
      /** Token Creator */
      token_creator?: string;
      collection: components["schemas"]["Collection"];
      /** Token Id */
      token_id?: string;
      /** Token Name */
      token_name?: string;
      /** Mint Context */
      mint_context?:
        | components["schemas"]["ManifoldMintContext"]
        | components["schemas"]["ZoraCreateMintContext"]
        | components["schemas"]["FoundationMintContext"]
        | components["schemas"]["ZoraCreate1155MintContext"]
        | components["schemas"]["ZoraCreatePremintContext"]
        | components["schemas"]["InferredMintContext"];
      /** Is Active */
      is_active: boolean;
      cost: components["schemas"]["zora__collect__feed__models__price_at_time__PriceAtTime"];
      total_mint_volume: components["schemas"]["zora__collect__feed__models__price_at_time__PriceAtTime"];
      /** Total Supply */
      total_supply?: number;
      /** Total Minted */
      total_minted: number;
      /** Wallet Max */
      wallet_max?: number;
      /**
       * Start Datetime
       * Format: date-time
       */
      start_datetime?: string;
      /**
       * End Datetime
       * Format: date-time
       */
      end_datetime?: string;
      collector_summary: components["schemas"]["CollectorSummary"];
      metadata?: components["schemas"]["zora__collect__contract__models__metadata__Metadata"];
      status?: components["schemas"]["MintableStatus"];
      /** Uuid */
      uuid?: string;
    };
    /**
     * MintableSortKey
     * @description An enumeration.
     * @enum {string}
     */
    MintableSortKey: "CREATED" | "MINTED";
    /**
     * MintableStatus
     * @description An enumeration.
     * @enum {string}
     */
    MintableStatus:
      | "ACTIVE"
      | "BLOCKED"
      | "EXPIRED"
      | "INVALID_MEDIA"
      | "MINTED_OUT"
      | "DELETED";
    /**
     * MintableType
     * @description An enumeration.
     * @enum {string}
     */
    MintableType:
      | "FOUNDATION_DROP_COLLECTION"
      | "FOUNDATION_TIMED_EDITION"
      | "MANIFOLD_ERC1155"
      | "MANIFOLD_ERC721"
      | "ZORA_CREATE"
      | "ZORA_CREATE_1155"
      | "ZORA_CREATE_1155_B2R_REDEEM_TOKEN"
      | "ZORA_CREATE_1155_PREMINT_TOKEN"
      | "ZORA_EDITION"
      | "ZORA_DROP"
      | "INFERRED";
    /**
     * Network
     * @description An enumeration.
     * @enum {string}
     */
    Network: "MAINNET" | "GOERLI";
    /** Notification */
    Notification:
      | components["schemas"]["MintNotification"]
      | components["schemas"]["MintCommentNotification"];
    /**
     * NotificationsResponse
     * @description This is a generic model for pagination in an infitite scrolling context.
     */
    NotificationsResponse: {
      /** Data */
      data: components["schemas"]["Notification"][];
      /** Limit */
      limit: number;
      /** Has More */
      has_more: boolean;
      cursor: components["schemas"]["Cursor"];
      /** Total Unread */
      total_unread: number;
    };
    /**
     * Platform
     * @description An enumeration.
     * @enum {string}
     */
    Platform: "FOUNDATION" | "ZORA" | "MANIFOLD" | "INFERRED";
    /**
     * PremintConfig
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    PremintConfig: {
      tokenConfig: components["schemas"]["TokenCreationConfig"];
      /** Uid */
      uid: number;
      /** Version */
      version: number;
      /** Deleted */
      deleted: boolean;
    };
    /**
     * Presale
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    Presale: {
      /** Token Id */
      token_id?: number;
      /** Presale Start */
      presale_start?: string;
      /** Presale End */
      presale_end?: string;
      /** Merkle Root */
      merkle_root?: string;
      /** Funds Recipient */
      funds_recipient?: string;
    };
    /** Price */
    Price: {
      /** Value */
      value: string;
    };
    /**
     * Royalties
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    Royalties: {
      /** Token Id */
      token_id?: number;
      /** User */
      user?: string;
      /** Royalty Bps */
      royalty_bps?: string;
      /** Royaltyrecipient */
      royaltyRecipient?: string;
      /** Royalty Mint Schedule */
      royalty_mint_schedule?: number;
    };
    /**
     * SaleStrategies
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    SaleStrategies: {
      /** Sale Strategies Type */
      sale_strategies_type?: string;
      fixed_price?: components["schemas"]["FixedPrice"];
      presale?: components["schemas"]["Presale"];
      /** Redeem Minter */
      redeem_minter?: boolean;
    };
    /** SearchCollection */
    SearchCollection: {
      /**
       * Entity Type
       * @default Collection
       * @enum {string}
       */
      entity_type?: "Collection";
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      /** Name */
      name?: string;
      /** Description */
      description?: string;
      /** Creator Address */
      creator_address?: string;
      /** Total Minted */
      total_minted?: number;
    };
    /** SearchResponse */
    SearchResponse: {
      /** Results */
      results: components["schemas"]["SearchResult"][];
      /** Total Results */
      total_results: number;
      /** Blocked Results */
      blocked_results: number;
      /** Limit */
      limit: number;
      /** Offset */
      offset: number;
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Api Version
       * @default 1
       */
      api_version?: number;
      /** Search Id */
      search_id: string;
    };
    /** SearchResult */
    SearchResult: {
      /** Name */
      name?: string;
      /** Description */
      description?: string;
      entity_type: components["schemas"]["EntityType"];
      /** Entity */
      entity:
        | components["schemas"]["SearchCollection"]
        | components["schemas"]["SearchToken"];
      media?: components["schemas"]["Media"];
      /**
       * Rank
       * @default 0
       */
      rank?: number;
    };
    /**
     * SearchSortKey
     * @description An enumeration.
     * @enum {string}
     */
    SearchSortKey: "CREATED" | "POPULARITY";
    /** SearchToken */
    SearchToken: {
      /**
       * Entity Type
       * @default Token
       * @enum {string}
       */
      entity_type?: "Token";
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id: string;
      /** Name */
      name?: string;
      /** Description */
      description?: string;
      /** Owner */
      owner?: string;
    };
    /**
     * SimpleResponse
     * @description A simple wrapper for data
     */
    SimpleResponse: {
      data: components["schemas"]["BaseModel"];
    };
    /**
     * SortDirection
     * @description An enumeration.
     * @enum {string}
     */
    SortDirection: "ASC" | "DESC";
    /**
     * TokenCreationConfig
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    TokenCreationConfig: {
      /** Tokenuri */
      tokenURI: string;
      /** Maxsupply */
      maxSupply: string;
      /** Maxtokensperaddress */
      maxTokensPerAddress: string;
      /** Pricepertoken */
      pricePerToken: string;
      /** Mintstart */
      mintStart: string;
      /** Mintduration */
      mintDuration: string;
      /** Royaltymintschedule */
      royaltyMintSchedule: number;
      /** Royaltybps */
      royaltyBPS: number;
      /** Royaltyrecipient */
      royaltyRecipient: string;
      /** Fixedpriceminter */
      fixedPriceMinter: string;
    };
    /** TokenMint */
    TokenMint: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      token_standard?: components["schemas"]["TokenStandard"];
      /** Originator Address */
      originator_address?: string;
      /** To Address */
      to_address: string;
      fee: components["schemas"]["Price"];
      /** Value */
      value?: number;
      transaction_info: components["schemas"]["TransactionInfo"];
    };
    /** TokenResult */
    TokenResult: {
      chain_name: components["schemas"]["ChainName"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id: string;
      token_standard?: components["schemas"]["TokenStandard"];
      /** Owner */
      owner?: string;
      metadata?: components["schemas"]["zora__collect__contract__models__metadata__Metadata"];
      mintable?: components["schemas"]["Mintable"];
      media?: components["schemas"]["Media"];
    };
    /**
     * TokenStandard
     * @description An enumeration.
     * @enum {string}
     */
    TokenStandard: "ERC721" | "ERC1155";
    /** TokensResponse */
    TokensResponse: {
      /** Results */
      results: components["schemas"]["TokenResult"][];
      /** Limit */
      limit: number;
      /** Offset */
      offset: number;
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Api Version
       * @default 1
       */
      api_version?: number;
    };
    /** Transaction */
    Transaction: {
      /** Chain Name */
      chain_name: string;
      /** Transaction Hash */
      transaction_hash: string;
      /** Block Number */
      block_number: number;
      /** Block Timestamp */
      block_timestamp: string;
    };
    /** TransactionInfo */
    TransactionInfo: {
      /** Block Number */
      block_number: number;
      /**
       * Block Timestamp
       * Format: date-time
       */
      block_timestamp: string;
      /** Transaction Hash */
      transaction_hash: string;
    };
    /** TrendingItem */
    TrendingItem: {
      /** Uuid */
      uuid: string;
      platform: components["schemas"]["Platform"];
      /** Collection Address */
      collection_address: string;
      /** Token Id */
      token_id?: string;
      /** Name */
      name: string;
      /** Token Name */
      token_name?: string;
      /** Num Mints Last Hour */
      num_mints_last_hour: number;
      /**
       * End Datetime
       * Format: date-time
       */
      end_datetime?: string;
      creator: components["schemas"]["Wallet"];
      /** Num Mints */
      num_mints: number;
      /**
       * Num Unique Minters In Window
       * @default 0
       */
      num_unique_minters_in_window?: number;
      /** Total Supply */
      total_supply?: number;
      /** Total Num Unique Collectors */
      total_num_unique_collectors: number;
      cost: components["schemas"]["zora__collect__trending__models__price_at_time__PriceAtTime"];
      /** Latest Mints */
      latest_mints: components["schemas"]["Mint"][];
      /** Rank */
      rank: number;
      /** Trending Duration */
      trending_duration: number;
      chain_name?: components["schemas"]["ChainName"];
    };
    /** TrendingResponse */
    TrendingResponse: {
      /** Trending Items */
      trending_items: components["schemas"]["TrendingItem"][];
    };
    /**
     * TrendingWindow
     * @description An enumeration.
     * @enum {string}
     */
    TrendingWindow: "now" | "1h" | "1d" | "7d";
    /** User */
    User: {
      /** Address */
      address: string;
      /** Total Minted */
      total_minted: number;
      /** Total Created */
      total_created: number;
      /** Total Owned */
      total_owned: number;
      first_transaction?: components["schemas"]["Transaction"];
      ens_record?: components["schemas"]["ENSRecord"];
    };
    /** UserOwnedToken */
    UserOwnedToken: {
      /** Balance */
      balance: number;
      token: components["schemas"]["TokenResult"];
    };
    /** UserTokensResponse */
    UserTokensResponse: {
      /** Results */
      results: components["schemas"]["UserOwnedToken"][];
      /** Limit */
      limit: number;
      /** Offset */
      offset: number;
      /** Has Next Page */
      has_next_page: boolean;
      /**
       * Api Version
       * @default 1
       */
      api_version?: number;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** Wallet */
    Wallet: {
      /** Address */
      address: string;
      /** Ens */
      ens?: string;
    };
    /** ZoraCreate1155MintContext */
    ZoraCreate1155MintContext: {
      /**
       * Mint Context Type
       * @default zora_create_1155
       * @enum {string}
       */
      mint_context_type?: "zora_create_1155";
      /** Renderer Contract */
      renderer_contract?: string;
      /** Permissions */
      permissions: components["schemas"]["ZoraCreatePermissions"][];
      /** Sale Strategies */
      sale_strategies: components["schemas"]["SaleStrategies"][];
      /** Royalties */
      royalties: components["schemas"]["Royalties"][];
      /** Contract Version */
      contract_version: string;
      /** Created At Block */
      created_at_block: number;
      /** Uri */
      uri?: string;
      /** B2R Redeemable */
      b2r_redeemable?: boolean;
    };
    /** ZoraCreateMintContext */
    ZoraCreateMintContext: {
      /**
       * Mint Context Type
       * @default zora_create
       * @enum {string}
       */
      mint_context_type?: "zora_create";
      /** Purchase */
      purchase: string;
      /** Price Per Token */
      price_per_token?: string;
      /** Purchase Presale */
      purchase_presale?: number;
      /** Presale Merkle Root */
      presale_merkle_root?: string;
      /** Max Sale Purchase Per Address */
      max_sale_purchase_per_address?: string;
      /** Contract Version */
      contract_version?: string;
    };
    /**
     * ZoraCreatePermissions
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    ZoraCreatePermissions: {
      /** User */
      user?: string;
      /** Token Id */
      token_id?: number;
      /** Is Admin */
      is_admin?: boolean;
      /** Is Minter */
      is_minter?: boolean;
      /** Is Sales Manager */
      is_sales_manager?: boolean;
      /** Is Metadata Manager */
      is_metadata_manager?: boolean;
      /** Is Funds Manager */
      is_funds_manager?: boolean;
    };
    /**
     * ZoraCreatePremintContext
     * @description ObjectBase extends Pydantic's BaseModel class to support extra functionality
     * (store_as, override_name), as well as provides other convinience methods.
     * ObjectBase allows for validation and type enforcement, and should be used inheritedfor any
     * complex type we include on a stored entity.
     *
     * Example::
     *     >>> class Foo(ObjectBase):
     *     ...:     found_at_height: int = field(override_name="address", store_as=str)
     *     ...:     other: str = "default"
     */
    ZoraCreatePremintContext: {
      /**
       * Mint Context Type
       * @default zora_create_premint
       * @enum {string}
       */
      mint_context_type?: "zora_create_premint";
      collection: components["schemas"]["CollectionCreationConfig"];
      premint: components["schemas"]["PremintConfig"];
      chain_name: components["schemas"]["ChainName"];
      /** Signature */
      signature: string;
    };
    /** Metadata */
    zora__collect__contract__models__metadata__Metadata: {
      /** Name */
      name?: string;
      /** Description */
      description?: string;
      /** Attributes */
      attributes: components["schemas"]["MediaAttribute"][];
    };
    /** Currency */
    zora__collect__feed__models__price_at_time__Currency: {
      /** Name */
      name?: string;
      /** Address */
      address: string;
      /**
       * Decimals
       * @default 18
       */
      decimals?: number;
    };
    /** CurrencyAmount */
    zora__collect__feed__models__price_at_time__CurrencyAmount: {
      currency: components["schemas"]["zora__collect__feed__models__price_at_time__Currency"];
      /** Raw */
      raw: string;
      /** Decimal */
      decimal: number;
    };
    /** PriceAtTime */
    zora__collect__feed__models__price_at_time__PriceAtTime: {
      native_price: components["schemas"]["zora__collect__feed__models__price_at_time__CurrencyAmount"];
      /** Block Number */
      block_number: number;
      eth_price?: components["schemas"]["zora__collect__feed__models__price_at_time__CurrencyAmount"];
      usdc_price?: components["schemas"]["zora__collect__feed__models__price_at_time__CurrencyAmount"];
    };
    /** MediaURI */
    zora__collect__trending__models__models__MediaURI: {
      /** Raw */
      raw: string;
      /** Mime Type */
      mime_type?: string;
      /** Encoded Large */
      encoded_large?: string;
      /** Encoded Preview */
      encoded_preview?: string;
    };
    /** Currency */
    zora__collect__trending__models__price_at_time__Currency: {
      /** Name */
      name?: string;
      /** Address */
      address: string;
      /**
       * Decimals
       * @default 18
       */
      decimals?: number;
    };
    /** CurrencyAmount */
    zora__collect__trending__models__price_at_time__CurrencyAmount: {
      currency: components["schemas"]["zora__collect__trending__models__price_at_time__Currency"];
      /** Raw */
      raw: string;
      /** Decimal */
      decimal: number;
    };
    /** PriceAtTime */
    zora__collect__trending__models__price_at_time__PriceAtTime: {
      native_price: components["schemas"]["zora__collect__trending__models__price_at_time__CurrencyAmount"];
      /** Block Number */
      block_number: number;
      eth_price?: components["schemas"]["zora__collect__trending__models__price_at_time__CurrencyAmount"];
      usdc_price?: components["schemas"]["zora__collect__trending__models__price_at_time__CurrencyAmount"];
    };
    /** Metadata */
    zora__ethereum__models__metadata__Metadata: {
      /** Name */
      name: string;
    };
    /** MediaURI */
    zora__media_encoding__media__MediaURI: {
      /** Raw */
      raw: string;
      /** Mime Type */
      mime_type?: string;
      /** Encoded Large */
      encoded_large?: string;
      /** Encoded Preview */
      encoded_preview?: string;
      /** Encoded Thumbnail */
      encoded_thumbnail?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /** Root */
  root__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /** Get Feed */
  get_feed_feed_get: {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
        mintable_types?: components["schemas"]["MintableType"][];
        feed_type?: components["schemas"]["FeedType"];
        allow_expired?: boolean;
        chain?: components["schemas"]["Chain"];
        network?: components["schemas"]["Network"];
      };
      cookie?: {
        device_id?: string;
        session_id?: string;
        wallet_address?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Relevant Mintables */
  gen_relevant_mintables_relevant_mintables__chain_name___collection_address___token_id__get: {
    parameters: {
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
        token_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Relevant Mintables */
  gen_relevant_mintables_relevant_mintables__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Feed Item Check */
  gen_feed_item_check_feed_item_check__chain_name___collection_address___token_id__get: {
    parameters: {
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
        token_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedItemCheck"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Feed Item Check */
  gen_feed_item_check_feed_item_check__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedItemCheck"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Mintable */
  gen_mintable_mintables__chain_name___collection_address___token_id__get: {
    parameters: {
      query?: {
        mintable_type?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
        token_id: string;
      };
      cookie?: {
        device_id?: string;
        session_id?: string;
        wallet_address?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Mintable"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Mintable */
  gen_mintable_mintables__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
        mintable_type?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
      cookie?: {
        device_id?: string;
        session_id?: string;
        wallet_address?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Mintable"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen All Mintables */
  gen_all_mintables_premints__chain_name__get: {
    parameters: {
      query?: {
        limit?: number;
        sort_direction?: components["schemas"]["SortDirection"];
        signer?: string;
        cursor?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["InfinitePage_Mintable_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Mintable V2 */
  gen_mintable_v2_mintables_v2__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedResult"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Backfill Contract */
  gen_backfill_contract_contract_backfill_post: {
    parameters: {
      query: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ContractBackfillResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get Contract */
  get_contract_contract__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ContractResult"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Contract Summaries */
  gen_contract_summaries_contract_summaries_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CollectionTokenId"][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ContractSummaryResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Gen Mint Counts
   * @deprecated
   * @description Use /contract_summaries instead
   */
  gen_mint_counts_mint_counts_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ContractQueryPayload"][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["MintCountsOutput"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Contracts */
  gen_contracts_contracts_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ContractQueryPayload"][];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ContractsQueryOutput"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Contract Tokens */
  gen_contract_tokens_tokens__chain_name___collection_address__get: {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
        sort_key?: components["schemas"]["MintableSortKey"];
        sort_direction?: components["schemas"]["SortDirection"];
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TokensResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Get User */
  get_user_user__wallet__get: {
    parameters: {
      query?: {
        chain_names?: components["schemas"]["ChainName"][];
        ens_chain_name?: components["schemas"]["ChainName"];
        chain_name?: components["schemas"]["ChainName"];
      };
      path: {
        wallet: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen User Tokens */
  gen_user_tokens_user__wallet_address__tokens_get: {
    parameters: {
      query?: {
        chain_names?: components["schemas"]["ChainName"][];
        offset?: number;
        limit?: number;
        sort_direction?: components["schemas"]["SortDirection"];
      };
      path: {
        wallet_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserTokensResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen User Contracts */
  gen_user_contracts_user__wallet_address__contracts_get: {
    parameters: {
      query?: {
        chain_names?: components["schemas"]["ChainName"][];
        offset?: number;
        limit?: number;
        sort_direction?: components["schemas"]["SortDirection"];
      };
      path: {
        wallet_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ContractsResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Trending */
  gen_trending_trending_get: {
    parameters: {
      query?: {
        trending_window?: components["schemas"]["TrendingWindow"];
        chain_names?: unknown;
        multichain?: unknown;
      };
      cookie?: {
        wallet_address?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TrendingResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Trending Feed */
  gen_trending_feed_trending_feed_get: {
    parameters: {
      query?: {
        trending_window?: components["schemas"]["TrendingWindow"];
        chain_names?: unknown;
        multichain?: unknown;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Search */
  gen_search_search_get: {
    parameters: {
      query: {
        text: string;
        chain_names?: components["schemas"]["ChainName"][];
        offset?: number;
        limit?: number;
        sort_key?: components["schemas"]["SearchSortKey"];
      };
      cookie?: {
        device_id?: string;
        session_id?: string;
        wallet_address?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Stream Token Mint */
  stream_token_mint_stream_token_mint__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
        timeout?: number;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Token Mints */
  gen_token_mints_token_mints__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
        limit?: number;
        sort_direction?: components["schemas"]["SortDirection"];
        cursor?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["InfinitePageWithTotal_TokenMint_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Stream Mint Comment */
  stream_mint_comment_stream_mint_comment__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
        timeout?: number;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Mint Comments */
  gen_mint_comments_mint_comments__chain_name___collection_address__get: {
    parameters: {
      query?: {
        token_id?: string;
        limit?: number;
        sort_direction?: components["schemas"]["SortDirection"];
        cursor?: string;
      };
      path: {
        chain_name: components["schemas"]["ChainName"];
        collection_address: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["InfinitePageWithTotal_MintComment_"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Gen Notifications */
  gen_notifications_notifications_get: {
    parameters: {
      query?: {
        chain_names?: components["schemas"]["ChainName"][];
        limit?: number;
        sort_direction?: components["schemas"]["SortDirection"];
        cursor?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationsResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Stream Notification */
  stream_notification_stream_notifications_get: {
    parameters: {
      query?: {
        chain_names?: components["schemas"]["ChainName"][];
        timeout?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Refresh Blocklist */
  refresh_blocklist_refresh_blocklist_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
  /** Schema */
  schema_schema_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
